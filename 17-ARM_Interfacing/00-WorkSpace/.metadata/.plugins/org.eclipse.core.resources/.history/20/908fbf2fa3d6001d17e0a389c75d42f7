/*
 * UART.c
 *
 *  Created on: Apr 6, 2023
 *      Author: Doaa Maher
 */

#include "NVIC.h"

#include "USART_Interface.h"
#include "USART_Config.h"

/* ====================== Defines ============================== */
#define				IDLE				0
#define				BUSY				1

#define				INIT				2
#define				NOT_INIT			3

#define				F_CPU				16000000
/* ============================ Types ====================== */
// USART Registers
typedef struct
{
	volatile u32 USART_SR;
	volatile u32 USART_DR;
	volatile u32 USART_BRR;
	volatile u32 USART_CR1;
	volatile u32 USART_CR2;
	volatile u32 USART_CR3;
	volatile u32 USART_GTPR;
}USART_tstr_Registers_t;

// Array of 3 Peripherals sharing same type : same registers [on APB1 bus]
USART_tstr_Registers_t * const volatile USART[3] = {
		/* USART1 */ [USART_enuUSART1] = {0x40011400},
		/* USART2 */ [USART_enuUSART2] = {0x40011000},
		/* USART6 */ [USART_enuUSART6] = {0x40004400},
};

/* ================= Static Global Vars for TX ================= */
// For TX States for the 3 USARTs : Initially not initialized
static u8 TX_State[3] = {NOT_INIT,NOT_INIT,NOT_INIT};
// For TX Buffer to be Sent [array of pointers]
static u8 *TX_Buffer[3] = {NULL_PTR,NULL_PTR,NULL_PTR};
// For TX Size for the 3 USARTs
static u32 TX_Size[3] = {0,0,0};
// For TX Indicies
static u32 TX_Index[3] = {0,0,0};

/* Callback function */
static Callback_t TX_Cbf[3] = {NULL_PTR,NULL_PTR,NULL_PTR};
/* ============================================================= */
/* ================= Static Global Vars for RX ================= */
// For RX States for the 3 USARTs : Initially not initialized
static u8 RX_State[3] = {NOT_INIT,NOT_INIT,NOT_INIT};
// For RX Buffer to be Received [array of pointers]
static u8 *RX_Buffer[3] = {NULL_PTR,NULL_PTR,NULL_PTR};
// For RX Size for the 3 USARTs
static u32 RX_Size[3] = {0,0,0};
// For RX Indicies
static u32 RX_Index[3] = {0,0,0};

/* Callback Function */
static Callback_t RX_Cbf[3] = {NULL_PTR,NULL_PTR,NULL_PTR};
/* ============================================================= */
/* ==================== Static Functions Prototypes ============== */
static void USART_voidBaudRate_USART_Calculation (void);
static void USART_voidHandler (USART_enuChannels USART_Channel);
/* =============================================================== */
/* ====================== Global Variables ========================= */
static u8 USART_USED=0;

/* ========================= APIs Implementation ============================ */
static void USART_voidBaudRate_USART_Calculation (void)
{
	/* 								 fClk
	 * TX/RX Baud Rate = ---------------------------------
	 * 						  8 x (2-OVER8) * USARTDIV
	 */

	f32 USARTDIV = 0;			// Has value in BRR

	u32 Mantissa_Part =0;
	u32 Fraction_Part =0;

	u8 Over8_Bit =0;

	u16 LocalBaudRate = USART_Cfg[USART_USED].USART_BaudRate;

	u32 LocalBuffer =0;
	// Get the Value of Oversampling
	Over8_Bit = USART_Cfg[USART_USED].USART_OverSampling;

	// Checking OVER8 Condition to know the fractional part bits (3 or 4)
	if (Over8_Bit == USART_enuOverSampling_DIV_16)			// = 0
	{
		Over8_Bit = 0;
		// Fractional part is coded on 4-bits
	}
	else if (Over8_Bit == USART_enuOverSampling_DIV_8)		// = 1
	{
		Over8_Bit =1;
		// Fractional part is coded on 3-bits
		// DIV_FractionBit3 must be cleared.
		LocalBuffer = USART[USART_USED]->USART_BRR;

		LocalBuffer &= USART_BRR_DIV_FRACTION_BIT3_CLR;
	}

	// Calculating USARTDIV Value & Cast it to f32:
	USARTDIV = ((f32)(F_CPU / LocalBaudRate*8*(2-Over8_Bit)));

	// Assign the Mantissa Part : By Casting USARTDIV to u32
	Mantissa_Part = (u32)USARTDIV;

	// Assign the Fraction Part : By Subtracting (USARTDIV - Mantissa)
	// Checking the OverSampling was 16 or 8
	switch (Over8_Bit)
	{
	case USART_enuOverSampling_DIV_16:
	{
		Fraction_Part = (USARTDIV - Mantissa_Part) * 16;
	}
	break;

	case USART_enuOverSampling_DIV_8:
	{
		Fraction_Part = (USARTDIV - Mantissa_Part) * 8;
	}
	break;
	}

	// Finally, Assign the Mantissa & Fraction To BRR Register
	USART[USART_USED]->USART_BRR = (Fraction_Part | USART_BRR_FRACTION_PART_SET);
	USART[USART_USED]->USART_BRR = (Mantissa_Part | USART_BRR_MANTISSA_PART_SET);
}
/************************************************************************************/
/* Before Transmitting the byte */
static void USART_voidHandler (USART_enuChannels USART_Channel)
{
	// Checking if trasmission is completed



}

/************************************************************************************/
USART_tenuErrorStatus USART_enuInit(const USART_tstrConfig_t *USART_Configurations)
{
	USART_tenuErrorStatus LocalErrorStatus = USART_enuOK;




	return LocalErrorStatus;

}
/************************************************************************************/
USART_tenuErrorStatus USART_enuSendAsynchZeroCpy (USART_enuChannels USART_Channel, u8 * Data_Buffer, u32 Data_Size , Callback_t Cpy_Cbf)
{
	USART_tenuErrorStatus LocalErrorStatus = USART_enuOK;


	return LocalErrorStatus;

}
/************************************************************************************/
USART_tenuErrorStatus USART_enuReceiveAsynchZeroCpy (USART_enuChannels USART_Channel, u8 * Received_Buffer, u32 Data_Size , Callback_t Cpy_Cbf)
{
	USART_tenuErrorStatus LocalErrorStatus = USART_enuOK;


	return LocalErrorStatus;

}
/************************************************************************************/
u8 USART_u8GetCurrentStatus (void)
{

}
/************************************************************************************/
